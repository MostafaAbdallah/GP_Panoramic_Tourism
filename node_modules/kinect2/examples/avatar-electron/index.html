<!DOCTYPE html>
<html>
	<head>
		<title>Hello World!</title>
		<style>
		body {
			background-color: white;
		}
		</style>
	</head>
	<body>
		<canvas id="outputCanvas"></canvas>
		<script src="../shared/js/fps.js"></script>
		<script src="js/dat.gui.js"></script>
		<script src="js/three.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script>
		(function(){
			var Kinect2 = require('../../lib/kinect2');
			var kinect = new Kinect2();

			var renderer, camera, scene, controls, loader;
			//load character
			var characterLoaded = false;
			var characterMesh;

			//bones viz
			var bonesVizBoneArray;
			var bonesVizBoneContainer;
			var positionVector = new THREE.Vector3();
			var lookVector = new THREE.Vector3();
			//end bones viz

			var rootBone;

			//index lookup objects
			var meshBoneIndexForKinect;
			var kinectBoneIndexForMesh;

			var ignoredPosition = new THREE.Vector3();
			var ignoredQuaternion = new THREE.Quaternion();
			var ignoredScale = new THREE.Vector3();

			var currentBody;

			var FACTOR = 200;

			var gui;

			function init() {
				renderer = new THREE.WebGLRenderer( {
					canvas: document.getElementById('outputCanvas'),
					alpha: 1, antialias: true, clearColor: 0xffffff
				} );

				camera = new THREE.PerspectiveCamera( 40, renderer.domElement.width / renderer.domElement.height, 1, 10000 );
				camera.position.set( 0, 300, 1000 );
				controls = new THREE.TrackballControls( camera, renderer.domElement );

				scene = new THREE.Scene();

				createBoneHierarchy();
				createGrid();
				loadCharacter();
				setupGUI();

				window.addEventListener( 'resize', onWindowResize, false );
				onWindowResize();
				render();

				/*
				if(kinect.open()) {
					kinect.on('bodyFrame', processBodyFrame);
					kinect.openBodyReader();
				}
				*/
				//work with recording
				var bodyFrames = require('../../bodyframes.json');
				var bodyFrameNr = 0;
				setInterval(function(){
					bodyFrameNr++;
					if(bodyFrameNr >= bodyFrames.length) {
						bodyFrameNr = 0;
					}
					processBodyFrame(bodyFrames[bodyFrameNr]);
				}, 33);
			}

			function createGrid() {
				// ground box
				var geometry = new THREE.BoxGeometry( 500, 2, 500 );
				material = new THREE.MeshNormalMaterial();
				var mesh = new THREE.Mesh( geometry, material );
				mesh.position.set( 0, -1, 0 );
				scene.add( mesh );
				mesh = new THREE.GridHelper( 250, 10 );
				scene.add( mesh );

				var axis = new THREE.AxisHelper( 250 );
				scene.add( axis );
				renderer.render( scene, camera );

				var geometry = new THREE.BoxGeometry( 50, 20, 50 );
				var material = new THREE.MeshNormalMaterial();
				var box = new THREE.Mesh( geometry, material );
				scene.add( box );
      }

      function generateTexture( color ) {
				var canvas = document.createElement( 'canvas' );
				canvas.width = 32;
				canvas.height = 32;

				var context = canvas.getContext( '2d' );
				context.fillStyle = color || "#ffffff";
				context.fillRect(0,0,32,32);

				return canvas;
			}

			function getJointIndexByName(boneName) {
				for(var i = characterMesh.skeleton.bones.length - 1; i > -1; i--) {
					if(characterMesh.skeleton.bones[i].name === boneName) {
						return i;
					}
				}
				return -1;
			}

			//mapping between kinect joints and characterMesh skeleton
			function mapJoints() {
				meshBoneIndexForKinect = {};
				//meshBoneIndexForKinect[Kinect2.JointType.head] = getJointIndexByName("Head");
				//meshBoneIndexForKinect[Kinect2.JointType.neck] = getJointIndexByName("Neck");
				meshBoneIndexForKinect[Kinect2.JointType.spineBase] = getJointIndexByName("Hips");

				meshBoneIndexForKinect[Kinect2.JointType.shoulderLeft] = getJointIndexByName("RightArm");
				//meshBoneIndexForKinect[Kinect2.JointType.elbowLeft] = getJointIndexByName("RightForeArm");
				//meshBoneIndexForKinect[Kinect2.JointType.handLeft] = getJointIndexByName("RightHand");

				//meshBoneIndexForKinect[Kinect2.JointType.shoulderRight] = getJointIndexByName("LeftArm");
				//meshBoneIndexForKinect[Kinect2.JointType.elbowRight] = getJointIndexByName("LeftForeArm");
				//meshBoneIndexForKinect[Kinect2.JointType.handRight] = getJointIndexByName("LeftHand");

				//meshBoneIndexForKinect[Kinect2.JointType.hipLeft] = getJointIndexByName("RightUpLeg");
				//meshBoneIndexForKinect[Kinect2.JointType.kneeLeft] = getJointIndexByName("RightLeg");
				//meshBoneIndexForKinect[Kinect2.JointType.footLeft] = getJointIndexByName("RightFoot");

				//meshBoneIndexForKinect[Kinect2.JointType.hipRight] = getJointIndexByName("LeftUpLeg");
				//meshBoneIndexForKinect[Kinect2.JointType.kneeRight] = getJointIndexByName("LeftLeg");
				//meshBoneIndexForKinect[Kinect2.JointType.footRight] = getJointIndexByName("LeftFoot");
				//create inverse lookup map
				kinectBoneIndexForMesh = {};
				for(var kinectIndex in meshBoneIndexForKinect) {
					kinectBoneIndexForMesh[meshBoneIndexForKinect[kinectIndex]] = kinectIndex;
				}
			}

			//hierarchy of kinect bones
			function createBoneHierarchy() {
				rootBone = { index: Kinect2.JointType.spineBase };
				var spineMidBone = { index: Kinect2.JointType.spineMid };
				var neckBone = { index: Kinect2.JointType.neck };
				var headBone = { index: Kinect2.JointType.head };
				var shoulderLeftBone = { index: Kinect2.JointType.shoulderLeft };
				var elbowLeftBone = { index: Kinect2.JointType.elbowLeft };
				var wristLeftBone = { index: Kinect2.JointType.wristLeft };
				var handLeftBone = { index: Kinect2.JointType.handLeft };
				var shoulderRightBone = { index: Kinect2.JointType.shoulderRight };
				var elbowRightBone = { index: Kinect2.JointType.elbowRight };
				var wristRightBone = { index: Kinect2.JointType.wristRight };
				var handRightBone = { index: Kinect2.JointType.handRight };
				var hipLeftBone = { index: Kinect2.JointType.hipLeft };
				var kneeLeftBone = { index: Kinect2.JointType.kneeLeft };
				var ankleLeftBone = { index: Kinect2.JointType.ankleLeft };
				var footLeftBone = { index: Kinect2.JointType.footLeft };
				var hipRightBone = { index: Kinect2.JointType.hipRight };
				var kneeRightBone = { index: Kinect2.JointType.kneeRight };
				var ankleRightBone = { index: Kinect2.JointType.ankleRight };
				var footRightBone = { index: Kinect2.JointType.footRight };
				var spineShoulderBone = { index: Kinect2.JointType.spineShoulder };
				var handTipLeftBone = { index: Kinect2.JointType.handTipLeft };
				var thumbLeftBone = { index: Kinect2.JointType.thumbLeft };
				var handTipRightBone = { index: Kinect2.JointType.handTipRight };
				var thumbRightBone = { index: Kinect2.JointType.thumbRight };

				addChildBone(rootBone, hipRightBone);
				addChildBone(hipRightBone, kneeRightBone);
				addChildBone(kneeRightBone, ankleRightBone);
				addChildBone(ankleRightBone, footRightBone);

				addChildBone(rootBone, hipLeftBone);
				addChildBone(hipLeftBone, kneeLeftBone);
				addChildBone(kneeLeftBone, ankleLeftBone);
				addChildBone(ankleLeftBone, footLeftBone);

				addChildBone(rootBone, spineMidBone);
				addChildBone(spineMidBone, spineShoulderBone);

				addChildBone(spineShoulderBone, neckBone);
				addChildBone(neckBone, headBone);

				addChildBone(spineShoulderBone, shoulderRightBone);
				addChildBone(shoulderRightBone, elbowRightBone);
				addChildBone(elbowRightBone, wristRightBone);
				addChildBone(wristRightBone, handRightBone);
				addChildBone(wristRightBone, thumbRightBone);
				addChildBone(handRightBone, handTipRightBone);

				addChildBone(spineShoulderBone, shoulderLeftBone);
				addChildBone(shoulderLeftBone, elbowLeftBone);
				addChildBone(elbowLeftBone, wristLeftBone);
				addChildBone(wristLeftBone, handLeftBone);
				addChildBone(wristLeftBone, thumbLeftBone);
				addChildBone(handLeftBone, handTipLeftBone);
			}

			//add child bone to kinect structure
			function addChildBone(parentBone, childBone) {
				if(!parentBone.children) {
					parentBone.children = [];
				}
				parentBone.children.push(childBone);
				childBone.parent = parentBone;
			}

			function processLoadedCharacter() {
				characterMesh.skeleton.bones.forEach(function(meshBone){
					//meshBone.matrixAutoUpdate = false;
				});
			}

			function loadCharacter() {
				loader = new THREE.JSONLoader();
				loader.load('assets/character.js', function (geometry) {
					var material;

					material = new THREE.MeshPhongMaterial( { color: 0xffffff, wireframe: true, opacity: 0.3, transparent: true, skinning: true, map: new THREE.Texture( generateTexture() ), normalMap: new THREE.Texture( generateTexture("#00ffff") ), specularMap: new THREE.Texture( generateTexture("#000000") ), bumpMap: new THREE.Texture( generateTexture("#000000") ) } );
					material.map.needsUpdate = true;
					material.normalMap.needsUpdate = true;
					material.specularMap.needsUpdate = true;
					material.bumpMap.needsUpdate = true;

					// create a characterMesh
					characterMesh = new THREE.SkinnedMesh(
						geometry,
						material
					);

					characterMesh.rotation.set(-Math.PI / 2, 0, 0);

					setupBonesViz(characterMesh);
					processLoadedCharacter();
					mapJoints();

					characterLoaded = true;

					scene.add(characterMesh);
				});
			}

			// Helpers - bones visualization
			function setupBonesViz( skin ) {

				bonesVizBoneArray = [];
				bonesVizBoneContainer = new THREE.Group();

				bonesVizBoneContainer.rotation = skin.rotation;

				scene.add(bonesVizBoneContainer);

				var index = 0;
				var m = new THREE.MeshBasicMaterial({color: 0xffff00, wireframe: true});

				for ( var b = 1; b != skin.skeleton.bones.length; b++ ) {

					var bone = skin.skeleton.bones[ b ];

					var nc = bone.children.length;

					for( var c = 0; c != nc; c++ ) {
						var child = bone.children[ c ];

						var size = Math.min( child.position.length()*0.12, 10);

						var boneViz = new THREE.Group();

						var cylinder = new THREE.CylinderGeometry( size, 0.1, child.position.length(), 5 );
				    cylinder.applyMatrix( new THREE.Matrix4().makeRotationFromEuler( new THREE.Euler( Math.PI / 2, 0, 0, 'XYZ') ) );
						cylinder.applyMatrix( new THREE.Matrix4().setPosition( new THREE.Vector3( 0, 0, 0.5 * child.position.length() ) ) );
						var mesh = new THREE.Mesh( cylinder, m );

						var axis = new THREE.AxisHelper( 10 );
						boneViz.add( axis );

						boneViz.add(mesh);

						bonesVizBoneArray[child.id] = boneViz;
						bonesVizBoneContainer.add( boneViz );
					}

				}

			}

			function removeBonesViz () {

				try {

					for (var i = 1; i < bonesVizBoneArray.length; i++) {
						bonesVizBoneArray.remove( bonesVizBoneArray[i] );
					}

					scene.remove(bonesVizBoneArray);

					bonesVizBoneArray = null;

				}
				catch (error) {
				}

			}

			function updateBonesViz ( skin ) {

				if (!bonesVizBoneArray) return;

				for ( var b = 1; b != skin.skeleton.bones.length; b++ ) {

					var bone = skin.skeleton.bones[b];
					var nc = bone.children.length;

					for( var c = 0; c != nc; c++ ) {

						var child = bone.children[c];
						var id = child.id;
						var boneViz = bonesVizBoneArray[id];

						positionVector.setFromMatrixPosition(child.matrixWorld);
						boneViz.position.copy(positionVector);

						lookVector.setFromMatrixPosition( child.parent.matrixWorld );
						boneViz.lookAt( lookVector );

					}

				}

			}

			function updateBody() {
				/*
				//update root bone
				var joint = currentBody.joints[Kinect2.JointType.spineBase];

				var scale = new THREE.Vector3(1, 1, 1);
				var translation = new THREE.Vector3(joint.cameraX * FACTOR, joint.cameraY * FACTOR, joint.cameraZ * FACTOR);
				var rotation = new THREE.Quaternion(joint.orientationX, joint.orientationY, joint.orientationZ, joint.orientationW);

				//characterMesh.skeleton.bones[meshBoneIndexForKinect[Kinect2.JointType.spineBase]].matrixAutoUpdate = false;
				characterMesh.skeleton.bones[meshBoneIndexForKinect[Kinect2.JointType.spineBase]].matrix.compose(translation, rotation, scale);

				//matrixAutoUpdate
				*/
				//applyBoneTransformations(currentBody, rootBone);
				var meshRootBone = characterMesh.skeleton.bones[meshBoneIndexForKinect[rootBone.index]];
				applyBoneTransformations(currentBody, meshRootBone);
			}

			var adjustEuler = new THREE.Euler( 2.3, 0, -1.5, 'ZXY' );
			var adjustQuaternion = new THREE.Quaternion();
			var guiParams = {
				enabledMovement: false
			};

			function setupGUI() {
				gui = new dat.GUI();

				gui.add(adjustEuler, 'x');
				gui.add(adjustEuler, 'y');
				gui.add(adjustEuler, 'z');
				gui.add(adjustEuler, 'order');

				gui.add(guiParams, 'enabledMovement');
			}

			function applyBoneTransformations(kinectBody, meshBone) {
				//console.log(meshBone);
				var parentMeshBone = false;
				var kinectJoint = false;

				var meshBoneIndex = characterMesh.skeleton.bones.indexOf(meshBone);
				var parentMeshBoneIndex = false;
				var kinectJointIndex = kinectBoneIndexForMesh[meshBoneIndex];
				if(kinectJointIndex) {
					kinectJoint = kinectBody.joints[kinectJointIndex];
				}

				//get the parent skeleton bone
				if(meshBone.parent && meshBone.parent.type === 'Bone') {
					parentMeshBone = meshBone.parent;
					parentMeshBoneIndex = characterMesh.skeleton.bones.indexOf(parentMeshBone);
				}

				var matrixWorld = new THREE.Matrix4();
				matrixWorld.getInverse(characterMesh.skeleton.boneInverses[meshBoneIndex]);

				var matrix = new THREE.Matrix4();
				if(parentMeshBone) {
					matrix.copy(characterMesh.skeleton.boneInverses[parentMeshBoneIndex]);
					matrix.multiply(matrixWorld);
				} else {
					matrix.copy(matrixWorld);
				}

				var bindQuaternion = new THREE.Quaternion();
				var targetQuaternion = new THREE.Quaternion();
				matrix.decompose(ignoredPosition, bindQuaternion, ignoredScale);


				//find the rotation that transforms the bone such that it points straight up (the direction vector is equal to (0, 1, 0). Call these the adjust rotations.

				if(!parentMeshBone) {
					//root bone
					//targetQuaternion.copy(bindQuaternion);
				} else {
					if(kinectJoint) {
						adjustQuaternion.setFromEuler(adjustEuler);
						console.log(adjustQuaternion);
						if(guiParams.enabledMovement) {
							//apply kinect
							var kinectQuaternion = new THREE.Quaternion(kinectJoint.orientationX, kinectJoint.orientationY, kinectJoint.orientationZ, kinectJoint.orientationW);
							var tmpQuaternion = new THREE.Quaternion();
							tmpQuaternion.multiplyQuaternions(kinectQuaternion, adjustQuaternion);
							targetQuaternion.multiplyQuaternions(tmpQuaternion, bindQuaternion);
						} else {
							targetQuaternion.copy(adjustQuaternion);
						}
					} else {
						targetQuaternion.copy(bindQuaternion);
					}

					//Then, to map a Kinect joint orientation (k) to a Unity humanoid bone transform (u):
					//u.rotation = k * (adjust rotation for bone) * (bind rotation for bone).

					meshBone.quaternion.copy(targetQuaternion);
				}




				/*

				*/



				/*
				var position = new THREE.Vector3();
				var quaternion = new THREE.Quaternion();
				var scale = new THREE.Vector3(1, 1, 1);

				meshBone.matrixWorld.getInverse(characterMesh.skeleton.boneInverses[meshBoneIndex]);

				var matrixWorldTransformed = meshBone.matrixWorld.clone();
				matrixWorldTransformed.decompose(position, quaternion, scale);

				if(parentMeshBone) {
					meshBone.matrix.getInverse( meshBone.parent.matrixWorld );
					if(kinectJoint) {
						//convert global to local orientation
						var globalQuaternion = new THREE.Quaternion(kinectJoint.orientationX, kinectJoint.orientationY, kinectJoint.orientationZ, kinectJoint.orientationW);

						//quaternion.set(kinectJoint.orientationX, kinectJoint.orientationY, kinectJoint.orientationZ, kinectJoint.orientationW);
					} else {
						//no kinect info - take parent orientation.. nope
						//meshBone.parent.matrix.decompose(ignoredPosition, quaternion, ignoredScale);
					}
					matrixWorldTransformed.compose(position, quaternion, scale);
					meshBone.matrixWorld.copy(matrixWorldTransformed);
					meshBone.matrix.multiply( matrixWorldTransformed );
				} else {
					if(kinectJoint) {
						quaternion.set(kinectJoint.orientationX, kinectJoint.orientationY, kinectJoint.orientationZ, kinectJoint.orientationW);
						position.set(kinectJoint.cameraX * FACTOR, kinectJoint.cameraY * FACTOR, kinectJoint.cameraZ * FACTOR);
					}
					matrixWorldTransformed.compose(position, quaternion, scale);
					meshBone.matrix.copy( matrixWorldTransformed );
				}
				*/

				if(meshBone.children) {
					meshBone.children.forEach(function(childMeshBone){
						applyBoneTransformations(kinectBody, childMeshBone);
					});
				}
			}

			function onWindowResize(){

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {
				renderer.render( scene, camera );
				controls.update();
				if(characterLoaded) {
					updateBonesViz(characterMesh);
				}
				requestAnimationFrame(render);
			}

			function processBodyFrame(bodyFrame) {
				if(!characterLoaded) {
					return;
				}
				currentBody = false;
				for (var i = bodyFrame.bodies.length - 1; i >= 0; i--) {
					if(bodyFrame.bodies[i].tracked) {
						currentBody = bodyFrame.bodies[i];
						break;
					}
				}
				if(!currentBody) {
					return;
				}
				updateBody();
			}

			init();

		})();
		</script>
	</body>
</html>
